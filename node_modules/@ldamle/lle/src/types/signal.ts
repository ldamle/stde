/**
 * Тип сигнала:
 * 1 - сигнал `1`
 * 0 - сигнал `0`
 * `x` - сигнал `x` (неопределенный)
 * `z` - сигнал `z` (обрыв)
 */
type it = 1 | 0 | 'x' | 'z';

/**
 * ! Стандартный способ задания сигналов элементов
 * Здесь задается один набор сигналов элемента
 * * Массив сигналов
 */
type array = string;

/**
 * Преобразует одиночный сигнал в массив с одним значением
 * @param signal
 */
function __getArrayIt(signal: it): array {
    if (signal === 0 || signal === 1) {
        return signal.toString();
    }
    return signal;
}

/**
 * Меняет index в массиве
 * @param signal
 * @param repl
 * @param index
 */
function __replByIndex(signal: array, repl: it, index: number): array {
    return signal.substring(0, index) + __getArrayIt(repl) + signal.substring(index + 1);
}
/**
 * ! Упрощенный способ задания сигналов элементов
 * * Массив состояний
 * Используется для описания состояния элемента при одном логическом сигнале.
 * `name`: имя состояния (строка)
 * `signal`: сигнал состояния (тип `Signal`)
 * `SignalArray`: массив сигналов, описывающий выходные сигналы
 * `StateArray`: объединение состояний элементов
 *
 * Пример:
 *
 * Состояние элемента: если вход `E_n` имеет сигнал 0, то все выходы элемента
 * будут {0, 0, 0, 0}
 * `const stateArray1: state = {name:'E_n', state:0, out:'0000'};`
 *
 * Состояние `else`: если сигнал не указан явно, то выходы будут {1, 0, 1, 0},
 * если текущий сигнал `x`
 * `const stateArray2: state = {name:'else', state:'x', out:'1010'};`
 *
 * Состояние `else`: если сигнал не указан явно, то выходы будут {0, 0, 0, 0}
 * `const stateArray2: state = {name:'else', state:0};
 *
 * Состояние `control` с сигналом 1 и вложенное состояние `enable` с сигналом 0,
 * результатом которого будет {1, 1, 1, 0}
 * `const nestedStateArray: state = {name: 'control', state: 1, {name: 'enable', state: 0, '1110'}};`
 *
 */
type state = {name: array; state: it; out?: array | state};

/**
 * * Массив состояний сигналов
 * Используется при описании всех сигналов элемента
 * Объеденияет в себе стандартный способ задания элементов и упрощенный
 * Пример:
 *```
 * const stateArray1: stateArray = [
 *      '101z',
 *      {name: 'E_n', state:0, out: '0000'},
 *      {name: 'else', state:'x', out: '1100'}
 * ];
 *```
 */
type stateArray = (array | state)[];

/**
 * ! Детальный способ задания сигналов элементов
 * * Массив сигналов входа и выхода
 * Сигнал входа в стандартном способе отсутствует, так как считается, что сигналы
 * выхода просто задаются по порядку, но это не всегда удобно, поэтому был создан
 * детальный способ создания с сигналами и входа и выхода
 * Пример:
 * ``
 * const DetailSignal1: detail = {in: '1000x', out: '100'};
 *```
 */
type detail = {in: array; out: array};

/**
 * * Массив детальных сигналов
 * Пример:
 * ```
 * const DetailSignalArray1: detailArray = [
 *      {in: '00x', out: '11'};
 *      {in: '01x', out: '10'};
 *      {in: '10x', out: '01'};
 *      {in: '11x', out: '00'};
 * ];
 * ```
 */
type detailArray = detail[];

/**
 * * Массив состояний сигналов
 * Используется при описании всех сигналов элемента
 * Объеденияет в себе детальный, стандартный и упрощенный способ задания сигналов элементов
 * Пример:
 *```
 * const DSSSArray1: detailStateArray = [
 *      '101z',   // стандартный способ
 *      {name: 'E_n', state: 0, out: '0000']], // упрощенный способ
 *      {in: '110', out: '0100'}, // детальный способ
 *      {name: 'else', state: 'x', out: '1100']  // упрощенный способ
 * ];
 * ```
 */
type detailStateArray = (detail | state | array)[];

/**
 * * Функция генерации сигналов
 * Для сложных элементов таблицы истинности будут занимать
 * колосальное количество строк, поэтому  предлагается использовать
 * функцию, которая по заданным входам сигналов будет выдавать выходы
 * Пример:
 * ```
 * function (in_signals: array): array {
 *   return "0000100010"; // выходы элемента всегда будут 0000100010 в независимости от входных сигналов
 * };
 * ```
 */
type func = (in_signals: array) => array;

/**
 * * Тип времени и сигналов для моделирования
 */
type time = {
    time: number;
    state: array;
};

/**
 * * Таблица со временем и сигналами
 */
type timeTable = time[];

export {
    it,
    array,
    state,
    stateArray,
    detail,
    detailArray,
    detailStateArray,
    func,
    time,
    timeTable,
    __getArrayIt,
    __replByIndex
};
